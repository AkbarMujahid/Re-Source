/**
 * @fileoverview Firestore Security Rules for the Re-Source application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for private user data and
 * employs a public-read, owner-write model for listings.  Administrative
 * privileges are granted based on the existence of a user document in the
 * `/roles_admin/{userId}` collection.
 *
 * Data Structure:
 * - /users/{userId}: Stores private user profile data.
 * - /listings/{listingId}: Stores public listings, each with a `userId` field
 *   indicating ownership.
 * - /chat_messages/{chatMessageId}: Stores chat messages.  Currently open, should be secured later.
 * - /users/{userId}/wishlists/{wishlistId}: Stores user-specific wishlists.
 * - /recommendations/{recommendationId}: Stores listing recommendations. Currently open, should be secured later.
 * - /reports/{reportId}: Stores reports of inappropriate content. Currently open, should be secured later and should only be writable by admins.
 * - /roles_admin/{userId}: Presence indicates admin role.
 *
 * Key Security Decisions:
 * - Users can only read and write their own profile data.
 * - Listings are publicly readable, but only the owner can create, update, or
 *   delete them.  The owner is determined by the `userId` field on the listing.
 * - Listing is denormalized with the `userId` to enable Authorization Independence.
 * - Wishlists are private and only accessible to the owning user.
 * - Listing is denormalized with the `userId` to enable Authorization Independence.
 * - `list` operations are generally allowed for user-owned subcollections.
 * - The chat_messages, recommendations, and reports collections are open for now.
 * - Admin status is determined by presence in the /roles_admin collection.
 *
 * Denormalization for Authorization:
 * - The `listings` collection denormalizes the `userId` to enable fast, secure
 *   ownership checks without additional reads.
 *
 * Structural Segregation:
 * - Private user data is stored under `/users/{userId}` and public listing
 *   data is stored under `/listings/{listingId}`.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is made by an authenticated user.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user ID matches the provided user ID.
     * @param {string} userId The user ID to compare against.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

        /**
     * @description Checks if the authenticated user exists as a document under `/roles_admin/{userId}`.
     * @return {boolean} True if the user is an admin, false otherwise.
     */
    function isAdmin() {
            return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * @description Checks if the authenticated user is the owner and the resource exists.
     * @param {string} userId The user ID to compare against.
     * @return {boolean} True if the user is the existing owner, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Defines rules for user profiles.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' can create their profile.
     *   `request.auth.uid == 'user123'`
     * @deny (create) User with ID 'user123' cannot create a profile with a mismatched ID.
     *   `request.auth.uid == 'user456'`
     * @allow (get) User with ID 'user123' can read their profile.
     *   `request.auth.uid == 'user123'`
     * @deny (get) User with ID 'user123' cannot read another user's profile.
     *   `request.auth.uid == 'user456'`
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow get: if isOwner(userId);
      allow list: if false;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Defines rules for listings.
     * @path /listings/{listingId}
     * @allow (create) User with ID 'user123' can create a listing with `userId: 'user123'`.
     *   `request.auth.uid == 'user123' && request.resource.data.userId == 'user123'`
     * @deny (create) User with ID 'user123' cannot create a listing with `userId: 'user456'`.
     *   `request.auth.uid == 'user123' && request.resource.data.userId == 'user456'`
     * @allow (get) Any user can read any listing.
     * @deny (update) User with ID 'user123' cannot update a listing they don't own.
     *   `request.auth.uid == 'user456' && resource.data.userId == 'user123'`
     * @principle Enforces document ownership for writes; allows public reads.
     */
    match /listings/{listingId} {
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow get, list: if true;
      allow update: if isSignedIn() && resource.data.userId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid && resource != null;
    }

    /**
     * @description Defines rules for chat messages.
     * @path /chat_messages/{chatMessageId}
     * @allow (get, list, create, update, delete) Any signed-in user can read, write, and delete any chat message.
     * @principle Currently open - requires further access control implementation.
     */
    match /chat_messages/{chatMessageId} {
      allow get, list, create, update, delete: if true; // TODO: Implement proper authorization
    }

    /**
     * @description Defines rules for wishlists.
     * @path /users/{userId}/wishlists/{wishlistId}
     * @allow (create) User with ID 'user123' can create a wishlist under their ID.
     *   `request.auth.uid == 'user123'`
     * @deny (create) User with ID 'user123' cannot create a wishlist under another user's ID.
     *   `request.auth.uid == 'user456'`
     * @allow (get) User with ID 'user123' can read their own wishlist.
     *   `request.auth.uid == 'user123'`
     * @deny (get) User with ID 'user123' cannot read another user's wishlist.
     *   `request.auth.uid == 'user456'`
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/wishlists/{wishlistId} {
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow get, list: if isOwner(userId);
      allow update: if isExistingOwner(userId) && request.resource.data.userId == userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Defines rules for recommendations.
     * @path /recommendations/{recommendationId}
     * @allow (get, list, create, update, delete) Any signed-in user can read, write, and delete any recommendation.
     * @principle Currently open - requires further access control implementation.
     */
    match /recommendations/{recommendationId} {
      allow get, list, create, update, delete: if true; // TODO: Implement proper authorization
    }

    /**
     * @description Defines rules for reports.
     * @path /reports/{reportId}
     * @allow (get, list, create, update, delete) Any signed-in user can read, write, and delete any report.
     * @principle Currently open - requires further access control implementation.
     */
    match /reports/{reportId} {
      allow get, list: if isAdmin();
      allow create: if isSignedIn();
      allow update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

          /**
     * @description Defines rules for admin role assignments.
     * @path /roles_admin/{userId}
     * @allow (create) User with ID 'user123' can create an admin role assignment.
     *   `request.auth.uid == 'user123'`
     * @deny (create) User with ID 'user123' cannot create an admin role assignment for another user.
     *   `request.auth.uid == 'user456'`
     *  @allow (get) Any signed in user can see who is an admin
     * @principle Enforces document ownership for writes.
     */
    match /roles_admin/{userId} {
          allow create: if isAdmin();
          allow get, list: if isAdmin();
          allow update, delete: if false;
    }
  }
}